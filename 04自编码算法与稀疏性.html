<html>
<head>
  <title>04自编码算法与稀疏性</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win32);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1157"/>
<h1>04自编码算法与稀疏性</h1>

<div>
<span><div><img src="04自编码算法与稀疏性_files/Image.png" type="image/png" data-filename="Image.png" style="height: auto;"/></div><div><br/></div><table style="border-collapse: collapse; margin-left: 0px; table-layout: fixed;width:100%;"><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:25%;"><div><img src="04自编码算法与稀疏性_files/Image [1].png" type="image/png" data-filename="Image.png" style="height:auto;" width="341"/></div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:25%;"><div><span style="font-size: 16px;"> 自编码神经网络尝试学习一个<img src="04自编码算法与稀疏性_files/43add74a1db8df97b8c6c18abeab16ec.png" type="image/png" data-filename="43add74a1db8df97b8c6c18abeab16ec.png" style="height: auto;"/>  的函数。换句话说，它尝试逼近一个恒等函数，从而使得输出 </span><img src="04自编码算法与稀疏性_files/Image [2].png" type="image/png" data-filename="Image.png" style="height: auto;"/> <span style="font-size: 16px;">接近于输入 </span><img src="04自编码算法与稀疏性_files/Image [3].png" type="image/png" data-filename="Image.png" style="height: auto;"/> <span style="font-size: 16px;">。</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">事实上，这一简单的自编码神经网络通常可以学习出一个跟主元分析（PCA）结果非常相似的输入数据的低维表示。</span></div><div><span style="font-size: 16px;"><br/></span></div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:49.92447129909365%;"><div><span style="font-size: 16px;">                 恒等函数虽然看上去不太有学习的意义，但是当我们为自编码神经网络加入某些限制，比如限定隐藏神经元的数量，我们就可以从输入数据中发现一些有趣的<span style="color: rgb(227, 0, 0);"><b>结构</b></span>。举例来说，假设某个自编码神经网络的输入 </span><img src="04自编码算法与稀疏性_files/Image [4].png" type="image/png" data-filename="Image.png" style="height: auto;"/> <span style="font-size: 16px;">是一张 </span><img src="04自编码算法与稀疏性_files/Image [5].png" type="image/png" data-filename="Image.png" style="height: auto;"/> <span style="font-size: 16px;">图像（共100个像素）的像素灰度值，于是 </span><img src="04自编码算法与稀疏性_files/Image [6].png" type="image/png" data-filename="Image.png" style="height: auto;"/> <span style="font-size: 16px;">，其隐藏层 </span><img src="04自编码算法与稀疏性_files/Image [7].png" type="image/png" data-filename="Image.png" style="height: auto;"/> <span style="font-size: 16px;">中有50个隐藏神经元。注意，输出也是100维的 </span><img src="04自编码算法与稀疏性_files/Image [8].png" type="image/png" data-filename="Image.png" style="height: auto;"/> <span style="font-size: 16px;">。由于只有50个隐藏神经元，<span style="color: rgb(209, 0, 255);"><b>我们迫使自编码神经网络去学习输入数据的压缩表示</b></span>，也就是说，它必须从50维的隐藏神经元激活度向量  中重构出100维的像素灰度值输入  。</span></div></td></tr></table><div><br/></div><div><span style="color: rgb(28, 51, 135);"><b><span style="font-size: 19px;">稀疏性：</span></b></span></div><div>       <span style="color: rgb(20, 113, 145);">   <span style="font-size: 16px;">如果当神经元的输出接近于1的时候我们认为它被激活，而输出接近于0的时候认为它被抑制，那么使得神经元大部分的时间都是被抑制的限制则被称作稀疏性限制。这里我们假设的神经元的激活函数是sigmoid函数。如果你使用tanh作为激活函数的话，当神经元输出为-1的时候，我们认为神经元是被抑制的。</span></span></div><div><br/></div><div><span style="color: rgb(28, 51, 135);"><b><span style="font-size: 19px;">激活度表示：</span></b></span></div><div><span style="font-size: 19px;"><span style="color: rgb(28, 51, 135);"><span style="font-size: 16px;"><span style="color: rgb(20, 113, 145);">        注意到 </span></span></span></span><img src="04自编码算法与稀疏性_files/Image [9].png" type="image/png" data-filename="Image.png"/> <span style="font-size: 19px;"><span style="color: rgb(28, 51, 135);"><span style="font-size: 16px;"><span style="color: rgb(20, 113, 145);">表示隐藏神经元 </span></span></span></span><img src="04自编码算法与稀疏性_files/Image [10].png" type="image/png" data-filename="Image.png"/> <span style="font-size: 19px;"><span style="color: rgb(28, 51, 135);"><span style="font-size: 16px;"><span style="color: rgb(20, 113, 145);">的激活度，但是这一表示方法中并未明确指出哪一个输入 </span></span></span></span><img src="04自编码算法与稀疏性_files/Image [11].png" type="image/png" data-filename="Image.png"/> <span style="font-size: 19px;"><span style="color: rgb(28, 51, 135);"><span style="font-size: 16px;"><span style="color: rgb(20, 113, 145);">带来了这一激活度。所以我们将使用 </span></span></span></span><img src="04自编码算法与稀疏性_files/Image [12].png" type="image/png" data-filename="Image.png"/> <span style="font-size: 19px;"><span style="color: rgb(28, 51, 135);"><span style="font-size: 16px;"><span style="color: rgb(20, 113, 145);">来表示在给定输入为 </span></span></span></span><img src="04自编码算法与稀疏性_files/Image [13].png" type="image/png" data-filename="Image.png"/> <span style="font-size: 19px;"><span style="color: rgb(28, 51, 135);"><span style="font-size: 16px;"><span style="color: rgb(20, 113, 145);">情况下，自编码神经网络隐藏神经元 </span></span></span></span><img src="04自编码算法与稀疏性_files/Image [14].png" type="image/png" data-filename="Image.png"/> <span style="font-size: 19px;"><span style="color: rgb(28, 51, 135);"><span style="font-size: 16px;"><span style="color: rgb(20, 113, 145);">的激活度。 进一步，让</span></span></span></span></div><div>                                                                 <img src="04自编码算法与稀疏性_files/Image [15].png" type="image/png" data-filename="Image.png"/></div><div><span style="color: rgb(20, 113, 145);"><span style="font-size: 16px;">表示隐藏神经元 </span></span><img src="04自编码算法与稀疏性_files/Image [16].png" type="image/png" data-filename="Image.png"/> <span style="color: rgb(20, 113, 145);"><span style="font-size: 16px;">的平均活跃度（在训练集上取平均）。我们可以近似的加入一条限制  ：  </span></span><img src="04自编码算法与稀疏性_files/Image [17].png" type="image/png" data-filename="Image.png"/></div><div>其中，  是稀疏性参数，通常是一个接近于0的较小的值（比如  <img src="04自编码算法与稀疏性_files/Image [18].png" type="image/png" data-filename="Image.png"/>）。换句话说，我们想要让隐藏神经元 <img src="04自编码算法与稀疏性_files/Image [19].png" type="image/png" data-filename="Image.png"/> 的平均活跃度接近0.05。为了满足这一条件，隐藏神经元的活跃度必须接近于0。</div><div><br/></div><div><b><span style="color: rgb(28, 51, 135);"><span style="font-size: 19px;">惩罚因子：</span></span></b></div><div><span style="font-size: 19px;"><span style="color: rgb(28, 51, 135);"><span style="color: rgb(20, 113, 145);"><span style="font-size: 16px;">        惩罚因子将惩罚那些 </span></span></span></span><img src="04自编码算法与稀疏性_files/Image [20].png" type="image/png" data-filename="Image.png"/> <span style="font-size: 19px;"><span style="color: rgb(28, 51, 135);"><span style="color: rgb(20, 113, 145);"><span style="font-size: 16px;">和 </span></span></span></span><img src="04自编码算法与稀疏性_files/Image [21].png" type="image/png" data-filename="Image.png"/> <span style="font-size: 19px;"><span style="color: rgb(28, 51, 135);"><span style="color: rgb(20, 113, 145);"><span style="font-size: 16px;">有显著不同的情况从而使得隐藏神经元的平均活跃度保持在较小范围内。惩罚因子的具体形式有很多种合理的选择，我们将会选择以下这一种：</span></span></span></span></div><div style="text-align: center"><img src="04自编码算法与稀疏性_files/Image [22].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><table style="-evernote-table:true;border-collapse:collapse;width:100%;table-layout:fixed;margin-left:0px;"><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:50%;"><div><img src="04自编码算法与稀疏性_files/Image [23].png" type="image/png" data-filename="Image.png" style="height:auto;" width="617"/></div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:50%;"><div><span style="color: rgb(20, 113, 145);"><span style="font-size: 16px;">我们可以看出，相对熵在 </span></span><img src="04自编码算法与稀疏性_files/Image [24].png" type="image/png" data-filename="Image.png"/> <span style="color: rgb(20, 113, 145);"><span style="font-size: 16px;">时达到它的最小值0，而当 </span></span><img src="04自编码算法与稀疏性_files/Image [25].png" type="image/png" data-filename="Image.png"/> <span style="color: rgb(20, 113, 145);"><span style="font-size: 16px;">靠近0或者1的时候，相对熵则变得非常大（其实是趋向于</span></span><img src="04自编码算法与稀疏性_files/Image [26].png" type="image/png" data-filename="Image.png"/><span style="color: rgb(20, 113, 145);"><span style="font-size: 16px;">）。所以，最小化这一惩罚因子具有使得 </span></span><img src="04自编码算法与稀疏性_files/Image [27].png" type="image/png" data-filename="Image.png"/> <span style="color: rgb(20, 113, 145);"><span style="font-size: 16px;">靠近 </span></span><img src="04自编码算法与稀疏性_files/Image [28].png" type="image/png" data-filename="Image.png"/> <span style="color: rgb(20, 113, 145);"><span style="font-size: 16px;">的效果。 现在，我们的总体代价函数可以表示为：</span></span></div><div style="text-align: center"><img src="04自编码算法与稀疏性_files/Image [29].png" type="image/png" data-filename="Image.png"/></div><div><img src="04自编码算法与稀疏性_files/Image [30].png" type="image/png" data-filename="Image.png"/></div></td></tr></table><div><br/></div><div><br/></div><div><b><span style="font-size: 19px;"><span style="color: rgb(28, 51, 135);"><br/></span></span></b></div><div><br/></div><div> </div></span>
</div></body></html> 