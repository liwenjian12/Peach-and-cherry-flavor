<html>
<head>
  <title>排序</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win32);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="587"/>
<h1>排序</h1>

<div>
<span><div><img src="排序_files/Image.png" type="image/png" data-filename="Image.png" style="font-weight: bold; font-size: 18pt; color: rgb(28, 51, 135);"/></div><div><font style="font-size: 18pt;"><span style="font-size: 18pt; color: rgb(28, 51, 135); font-weight: bold;">冒泡排序</span></font></div><div><br/></div><div><ul><li>第一次遍历</li></ul></div><div>要比较相邻的两项，并且交换顺序排错的项</div><div>每对列表实行<font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(173, 0, 0); font-weight: bold;">一次遍历，就有一个最大项排在了正确的位置</span></font>。</div><div>如果列表有n项，第一次遍历就要比较n-1对数据。</div><div><img src="排序_files/Image [1].png" type="image/png" data-filename="Image.png" width="471"/></div><div><br/></div><div><ul><li>第二次遍历</li></ul><div>第二次遍历开始时，最大的数据项已经归位。现在还剩n-1个待排数据项，即有n-2个要比较的数据对。</div></div><div><ul><li>交换（swap）</li></ul><div>Python中的交换操作与其他许多编程语言不同。通常来说，交换列表中的两项需要一个暂存位置（一个附加的储存空间）。以上这段代码可以交换列表中的第i项和第j项。如果没有暂存位置的话，其中一个值就会被覆盖。</div></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">temp = alist[i]</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">alist[i] = alist[j]</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">alist[j] = temp</span></div></div><div>但是在Python里，可以“同时赋值”。通过<font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(173, 0, 0); font-weight: bold;">“a,b=b,a”</span></font>的语句就可以让两个赋值语句同时进行（如图2）</div><div><img src="排序_files/Image [2].png" type="image/png" data-filename="Image.png" width="268"/></div><div><br/></div><div><br/></div><div><ul><li>冒泡排序完整代码</li></ul><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">def bubbleSort(alist)</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    for passnum in range(len(alist) - 1, 0, -1):</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        for i in range(passnum):</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">            if alist[i] &gt; alist[i + 1]:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                <span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">temp = alist[i]</span></span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">                            alist[i] = alist[i+1]</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">                            alist[i+1] = temp</span></div></div></div><div><br/></div><div><ul><li>冒泡排序改良（短路冒泡排序）</li></ul><div>冒泡排序必须要在最终位置找到之前不断交换数据项，所以它经常被认为是最低效的排序方法</div></div><div>如果一个列表只需要几次遍历就可排好，冒泡排序就占有优势：它可以在发现列表已排好时立刻结束</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>def shortBubbleSort(alist):</div><div><span>    exchanges = True</span><br/></div><div><span><span>    passnum = len(alist) - 1</span><br/></span></div><div><span><span>    while passnum &gt; 0 and exchanges:</span><br/></span></div><div><span><span>    <span>    exchanges = False</span></span><br/></span></div><div><span><span>    <span>    for i in range(passnum):</span></span><br/></span></div><div><span><span>    <span>    <span>    if alist[i] &gt; alist[i+1]:</span></span></span><br/></span></div><div><span><span>    <span>    <span>    <span>    exchange = True</span></span></span></span><br/></span></div><div><span><span>    <span>    <span>    <span>    temp = alist[i]</span></span></span></span><br/></span></div><div><span><span>    <span>    <span>    <span>    alist = alist[i+1]</span></span></span></span><br/></span></div><div><span><span>    <span>    <span>    <span>    alist[i+1] = temp</span></span></span></span><br/></span></div><div><span><span>    <span>    <span>    passnum = passnum - 1</span></span></span><br/></span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><font style="font-size: 18pt; color: rgb(28, 51, 135);"><b>选择排序</b></font></div><div><br/></div><div><ul><li><span>每遍历一次列表只交换一次数据，提高了冒泡排序的性能</span></li><li><span>找到最大的项，完成遍历后，再把它换到正确的位置</span></li></ul></div><div><img src="排序_files/Image [3].png" type="image/png" data-filename="Image.png" width="388"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>def selectionSort(alist):</div><div><span>    for fillslot in range(len(alist)-1, 0, -1):</span><br/></div><div><span><span>    <span>    postionOfMax = 0</span></span><br/></span></div><div><span><span>    <span>    for location in range(1, fillslot+1):</span></span><br/></span></div><div><span><span>    <span>    <span>    if alist[location] &gt; alist[positionOfMax]:</span></span></span><br/></span></div><div><span><span>    <span>    <span>    <span>    positionOfMax = location</span></span></span></span><br/></span></div><div><span><br/></span></div><div><span>temp = alist[fillslot]</span></div><div><span>alist[fillslot] = alist[positionOfMax]</span></div><div><span>alist[positionOfMax] = temp</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><font style="font-size: 18pt; color: rgb(28, 51, 135);"><b>插入排序</b></font></div><div><ul><li><span>插入排序的算法复杂度仍然是O(n</span><span>2</span><span>)</span></li><li><span>总是保持一个位置靠前的已排好的子表，然后每一个新的数据项被“插入”到前边的子表里，排好的子表增加一项。</span></li></ul><div><img src="排序_files/Image [4].png" type="image/png" data-filename="Image.png" width="400"/></div></div><div><ul><li><span>比较时，我们把之前已经排好的列表中比这个数据大的移到它的右边。</span></li></ul></div><div><span>了第五步排序的过程。程序运行到当前位置，已排好的子表中包含了“17，26，54，77，93”五个数据。我们想让31插入该子表中。第一次，31和93比较，93要移到31右边。同理，77和54也要移位。遇到26时，移动步骤停止，31被插入到此处。此时我们就有了一个含6个数据项的已排好的子表。</span></div><div><ul><li><span>关于“转移”与“交换”操作的考虑也很重要。通常情况下，“转移”的步骤约为“交换”步骤的1/3，因为它只有一次赋值操作。</span></li></ul></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>def insertionSort(alist):</div><div><span>    for index in range(1, len(alist)):</span><br/></div><div><span><span>    <span>    currentvalue = alist[index]</span></span><br/></span></div><div><span><span>    <span>    position = index</span></span><br/></span></div><div><span><span>    <span>    while position &gt; 0 and alist[position-1] &gt; currentvalue:</span></span><br/></span></div><div><span><span>    <span>    <span>    alist[position] = alist[position-1]</span></span></span><br/></span></div><div><span>    <span>    <span>    position = position - 1</span></span></span></div><div><span>    <span>    <span>    alist[position] = currentvalue</span></span></span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span><font style="font-size: 18pt; color: rgb(28, 51, 135);"><b>希尔排序</b></font></span></div><div><ul><li><span>将原来要排序的列表划分为一些子列表，再对每一个子列表执行插入排序，从而实现对插入排序性能的改进。</span></li><li><span>确定一个划分列表的增量</span><span>“i”</span><span>，这个</span><span>i</span><span>更准确地说，是划分的间隔</span></li></ul></div><div><img src="排序_files/Image [5].png" type="image/png" data-filename="Image.png" width="378"/></div><div><span>图 5.6 以3为间隔的希尔排序</span></div><div><img src="排序_files/Image [6].png" type="image/png" data-filename="Image.png" width="427"/></div><div><ul><li><span>最终以</span><span>1</span><span>为间隔进行插入排序<span>，即标准的插入排序的过程。</span></span></li></ul></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>def shellSort(alist):</div><div><span>    sublistcount = len(alist)//2</span><br/></div><div><span><span>    while sublistcount &gt; 0:</span><br/></span></div><div><span><span>    </span><br/></span></div><div><span><span>    for startpostion in range(sublistcount):</span><br/></span></div><div><span><span>    <span>    gapInsetionSort(alist, startposition, sublistcount)</span></span><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    <span>    <span>    <span>  </span></span></span></span>print(&quot;After increments of size&quot;,sublistcount, </span><span style="font-family: Monaco; font-size: 9pt; line-height: 1.45;">&quot;The list is&quot;,alist)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    <span>    </span></span>sublistcount = sublistcount // 2</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">def gapInsertionSort(alist,start,gap):</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    <span>    </span></span>for i in range(start+gap,len(alist),gap):</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    <span>    <span>    </span></span></span>currentvalue = alist[i]</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    <span>    <span>    </span></span></span>position = i</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    <span>    <span>    </span></span></span>while position&gt;=gap and alist[position-gap]&gt;currentvalue:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    <span>    <span>    <span>    </span></span></span></span>alist[position]=alist[position-gap]</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    <span>    <span>    <span>    </span></span></span></span>position = position-gap</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    <span>    <span>    <span>    </span></span></span></span>alist[position]=currentvalue</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    <span>    <span>    <span>    </span></span></span></span>alist = [54,26,93,17,77,31,44,55,20]</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">shellSort(alist)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">print(alist)</span> <span><span>    </span><br/></span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><font style="font-size: 18pt; color: rgb(28, 51, 135);"><b>归并排序</b></font></div><div><span>分而治之的策略来改进排序算法的表现。我们要学的第一种算法就是归并排序。</span></div><div><span>。归并排序是一种递归算法，它持续地将一个列表分成两半。如果列表是空的或者只有一个元素，那么根据定义，它就被排序好了（最基本的情况）。如果列表里的元素超过一个，我们就把列表拆分，然后分别对两个部分调用递归排序。一旦这两个部分被排序好了，那么这种被叫做归并的最基本的操作，就被执行了。</span></div><div><br/></div><div><br/></div><div><br/></div><div><span><font style="font-size: 18pt; color: rgb(28, 51, 135);"><b>快速排序</b></font></span></div><div><span>快速排序用了和归并排序一样分而治之的方法来获得同样的优势，但同时不需要使用额外的存储空间。经过权衡之后，我们发现列表不分离成两半是可能的，当这发生的时候，我们可以看到，操作减少了。</span></div><div><br/></div><div><span>快速排序首先选择一个中值。虽然有很多不同的方法来选择这个数值，我们将会简单地选择列表里的第一项。中值的作用在于协助拆分这个列表。中值在最后排序好的列表里的实际位置，我们通常称之为分割点的，是用来把列表变成两个部分来随后分别调用快速排序函数的。</span></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 