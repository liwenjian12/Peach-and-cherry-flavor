<html>
<head>
  <title>排序（复杂）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win32);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="586"/>
<h1>排序（复杂）</h1>

<div>
<span><div><h2><span style="font-weight: bold; color: rgb(28, 51, 135); font-size: 24pt;">排序-sorting</span></h2><div><ul><li><span style="font-size: 32px;"><span style="color: rgb(28, 51, 135); font-size: 32px; line-height: 46px; font-weight: bold;">Comparison Sorting</span></span></li></ul><div style="text-align: center;"><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 343px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 343px; padding: 8px;"><ol><li>Bubble Sort</li><li>Selection Sort</li><li>Insertion Sort</li><li>Shell Sort</li><li>Merge Sort</li><li>Quck Sort</li><li>Heap Sort</li></ol></td></tr></tbody></table><div><br/></div></div></div><div><br/></div><ul><li><span style="font-size: 32px;"><span style="color: rgb(28, 51, 135); font-size: 32px; line-height: 46px; font-weight: bold;">Bucket Sort</span></span></li><li><span style="font-size: 32px;"><span style="color: rgb(28, 51, 135); font-size: 32px; line-height: 46px; font-weight: bold;">Counting Sort</span></span></li><li><span style="font-size: 32px;"><span style="color: rgb(28, 51, 135); font-size: 32px; line-height: 46px; font-weight: bold;">Radix Sort</span></span></li></ul></div><h2><br/></h2><h2><span style="font-size: 15pt; font-weight: bold;">从稳定性角度考虑可分为如下两类：</span></h2><ul><li><font color="#1C3387" style="font-size: 24pt;"><span style="color: rgb(28, 51, 135); font-size: 24pt; font-weight: bold;">稳定</span></font></li><li><font color="#1C3387" style="font-size: 24pt;"><span style="color: rgb(28, 51, 135); font-size: 24pt; font-weight: bold;">非稳定</span></font></li></ul><h2><br/></h2><h2><br/></h2><h2><span style="font-size: 15pt; font-weight: bold;">核心：快排是一种采用分治思想的排序算法，大致分为三个步骤。</span></h2><ol><li>定基准——首先随机选择一个元素最为基准</li><li>划分区——所有比基准小的元素置于基准左侧，比基准大的元素置于右侧</li><li>递归调用——递归地调用此切分过程</li></ol><h2>out-in-place - 非原地快排</h2><div>容易实现和理解的一个方法是采用递归，使用 Python 的 list comprehension 实现如下所示：</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">#!/usr/bin/env python</span></div><div><br/></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">def qsort1(alist):</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    print(alist)</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    if len(alist) &lt;= 1:</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        return alist</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    else:</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        pivot = alist[0]</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        return qsort1([x for x in alist[1:] if x &lt; pivot]) + \</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">               [pivot] + \</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">               qsort1([x for x in alist[1:] if x &gt;= pivot])</span></div><div><br/></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">unsortedArray = [6, 5, 3, 1, 8, 7, 2, 4]</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">print(qsort1(unsortedArray))</span></div></div><div><br/></div><h2>in-place - 原地快排</h2><h3>one index for partition</h3><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><font color="#1C3387" style="font-size: 16pt;"><span style="color: rgb(28, 51, 135); font-size: 16pt; font-weight: bold;">Bubble Sort-冒泡排序</span></font></div><div><br/></div><div><font style="font-size: 12pt;"><span style="color: rgb(227, 0, 0); font-size: 12pt; font-weight: bold;">Python</span></font></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">def bubbleSort(alist):</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    for i in xrange(len(alist)):</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        print(alist)</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        for j in xrange(1, len(alist) - i):</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">            if alist[j - 1] &gt; alist[j]:</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                alist[j - 1], alist[j] = alist[j], alist[j -1]</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    return alist</span></div></div><h3><span style="color: rgb(227, 0, 0); font-size: 12pt;">复杂度分析</span></h3><div>平均情况与最坏情况均为 O(n2), 使用了 temp 作为临时交换变量，空间复杂度为 O(1).</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><h1><span style="color: rgb(28, 51, 135); font-size: 16pt;">Selection Sort - 选择排序</span></h1><div>核心：不断地选择剩余元素中的最小者</div><ol><li>找到数组中最小元素并将其和数组第一个元素交换位置。</li><li>在剩下的元素中找到最小元素并将其与数组第二个元素交换，直至整个数组排序。</li></ol><div>性质：</div><div><ul><li>比较次数=（N-1) + (N-2)+(N-3)+...+2+1 ~ N^2/2</li><li>交换次数= N</li><li>运行时间与输入无关</li><li>数据移动最少</li></ul></div><div><font style="font-size: 12pt;"><span style="color: rgb(227, 0, 0); font-size: 12pt; font-weight: bold;">Python</span></font></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">def selectionSort(alist):</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    for i in xrange(len(alist)):</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        print(alist)</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        min_index = i</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        for j in xrange(i + 1, len(alist)):</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">            if alist[j] &lt; alist[min_index]:</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                min_index = j</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        alist[min_index], alist[i] = alist[i], alist[min_index]</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    return alist</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="color: rgb(28, 51, 135); font-size: 16pt; font-weight: bold;">Insertion Sort - 插入排序</span></font></div><div><br/></div><div>核心：通过构建有序序列， 对于未排序序列，在已排序序列中从后向前扫描（对于单向链表则只能从前往后遍历）， 找到相应位置并插入。实现上通常使用in-place排序（需用到O(1)的额外空间）</div><ol><li>从第一个元素开始，该元素可认为已排序</li><li>取下一个元素，对已排序数组从后往前扫描</li><li>若从排序数组中取出的元素大于新元素，则移至下一位置</li><li>重复步骤3，直至找到已排序元素小于或等于新元素的位置</li><li>插入新元素至该位置</li><li>重复2~5</li></ol><div><br/></div><div>性质：</div><ul><li>交换操作和数组中倒置的数量相同</li><li>比较次数&gt;=倒置数量，&lt;=倒置的数量加上数组的大小减一</li><li>每次交换都改变了两个顺序颠倒的元素的位置，即减少了一对倒置，倒置数量为0时即完成排序。</li><li>每次交换对应着一次比较，且1到N-1之间的每个i都可能需要一次额外的记录(a[i]未到达数组左端时)</li><li>最坏情况下需要~N^2/2次比较和~N^2/2次交换，最好情况下需要N-1次比较和0次交换。</li><li>平均情况下需要~N^2/4次比较和~N^2/4次交换</li></ul><div><br/></div><div><font style="font-size: 12pt;"><span style="color: rgb(227, 0, 0); font-size: 12pt; font-weight: bold;">python</span></font></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">def insertionSort(alist):</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    for i, item_i in enumerate(alist):</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        print alist</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        index = i</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        while index &gt; 0 and alist[index -1] &gt; item_i:</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">            alist[index] = alist[index -1]</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">            index -= 1</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        alist[index] = item_i</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    return alist</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="color: rgb(28, 51, 135); font-size: 16pt; font-weight: bold;">希尔排序</span></font></div><div><br/></div><div>核心：基于插入排序，使数组中任意间隔为h的元素都是有序的，即将全部元素分为h个区域使用插入排序。其实现可类似于插入排序但使用不同增量。更高效的原因是它权衡了子数组的规模和有序性。</div><div>实现(C++):</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">template&lt;typename T&gt;</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">void shell_sort(T arr[], int len) {</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    int gap, i, j;</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    T temp;</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    for (gap = len &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1)</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        for (i = gap; i &lt; len; i++) {</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">            temp = arr[i];</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">            for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap)</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                arr[j + gap] = arr[j];</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">            arr[j + gap] = temp;</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        }</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">}</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="color: rgb(28, 51, 135); font-size: 16pt; font-weight: bold;">Merge Sort - 归并排序</span></font></div><div><br/></div><div>核心：将两个有序对数组归并成一个更大的有序数组。通常做法为递归排序， 并将两个不同的有序数组归并到第三个数组中。</div><div><font color="#E30000" style="font-size: 12pt;"><span style="color: rgb(227, 0, 0); font-size: 12pt; font-weight: bold;">Python</span></font></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">class Sort:</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    def mergeSort(self, alist):</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        if len(alist) &lt;= 1:</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">            return alist</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        mid = len(alist) / 2</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        left = self.mergeSort(alist[:mid])</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        print(&quot;left = &quot; + str(left))</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        right = self.mergeSort(alist[mid:]_</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        print(&quot;right = &quot; + str(right))</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        return self.mergeSortedArray(left, right)</span></div><div><br/></div><div><br/></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">       #@param A and B: sorted integer array A and B.</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">       #@return: A new sorted integer array</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    def mergeSortedArray(self, A, B):</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        sortedArray = []</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        l = 0</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        r = 0</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        while l &lt; len(A) and r &lt; len(B):</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">            if A[l] &lt; B[r]：</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                sortedArray.append(A[l])</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                l += 1</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">            else:</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                sortedArray.append(B[r])</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        sortedArray += A[l:]</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        sortedArray += B[r:]</span></div><div><br/></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        return sortedArray</span></div><div><br/></div><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><font color="#1C3387" style="font-size: 16pt;"><span style="color: rgb(28, 51, 135); font-size: 16pt; font-weight: bold;">Heap Sort - 堆排序</span></font></div><div><span style="font-size: 12pt;">堆排序通常基于</span><a href="http://algorithm.yuanbin.me/zh-cn/basics_data_structure/heap.html" style="font-size: 12pt; font-weight: bold;">二叉堆</a> <span style="font-size: 12pt;">实现，以大根堆为例，堆排序的实现过程分为两个子过程。第一步为取出大根堆的根节点(当前堆的最大值), 由于取走了一个节点，</span><span style="font-size: 12pt; color: rgb(173, 0, 0); font-weight: bold;">故需要对余下的元素重新建堆。重新建堆后继续取根节点，循环直至取完所有节点，此时数组已经有序。</span><span style="font-size: 12pt;">基本思想就是这样，不过实现上还是有些小技巧的。</span></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="color: rgb(28, 51, 135); font-size: 16pt; font-weight: bold;">Bucket Sort</span></font></div><div><br/></div><div>桶排序和归并排序有那么点点类似，也使用了归并的思想。大致步骤如下：</div><ol><li>设置一个定量的数组当作空桶。</li><li>Divide - 从待排序数组中取出元素，将元素<font style="font-size: 12pt;"><span style="color: rgb(227, 0, 0); font-size: 12pt; font-weight: bold;">按照一定的规则</span></font>塞进对应的桶子去。规则是自己规定的，别人需要被告知才会知道！！！！！！！</li><li>对每个非空桶进行排序，<font style="font-size: 16pt;"><span style="color: rgb(227, 0, 0); font-size: 16pt; font-weight: bold;">通常可在塞元素入桶时进行插入排序</span></font>。</li><li>Conquer - 从非空桶把元素再放回原来的数组中。</li></ol><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="color: rgb(28, 51, 135); font-size: 16pt; font-weight: bold;">Counting Sort</span></font></div><div><br/></div><div>计数排序，顾名思义，就是对待排序数组按元素进行计数。使用前提是需要先知道待排序数组的元素范围，将这些一定范围的元素置于新数组中，新数组的大小为待排序数组中最大元素与最小元素的差值。</div><div style="margin-top: 1em; margin-bottom: 1em;">维基上总结的四个步骤如下：</div><ol><li>定新数组大小——找出待排序的数组中最大和最小的元素</li><li>统计次数——统计数组中每个值为i的元素出现的次数，存入新数组C的第i项</li><li>对统计次数逐个累加——对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li><li>反向填充目标数组——将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li></ol><div>其中反向填充主要是为了避免重复元素落入新数组的同一索引处。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><h1><span style="color: rgb(28, 51, 135); font-size: 16pt;">Radix Sort</span></h1><div style="margin-top: 1em; margin-bottom: 1em;">经典排序算法 - 基数排序Radix sort</div><div style="margin-top: 1em; margin-bottom: 1em;">原理类似桶排序,这里总是需要10个桶,多次使用</div><div style="margin-top: 1em; margin-bottom: 1em;">首先以个位数的值进行装桶,即个位数为1则放入1号桶,为9则放入9号桶,暂时忽视十位数</div><div style="margin-top: 1em; margin-bottom: 1em;">例如</div><div style="margin-top: 1em; margin-bottom: 1em;">待排序数组[62,14,59,88,16]简单点五个数字</div><div style="margin-top: 1em; margin-bottom: 1em;">分配10个桶,桶编号为0-9,以个位数数字为桶编号依次入桶,变成下边这样</div><div style="margin-top: 1em; margin-bottom: 1em;">| 0 | 0 | 62 | 0 | 14 | 0 | 16 | 0 | 88 | 59 |</div><div style="margin-top: 1em; margin-bottom: 1em;">| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |桶编号</div><div style="margin-top: 1em; margin-bottom: 1em;">将桶里的数字顺序取出来,</div><div style="margin-top: 1em; margin-bottom: 1em;">输出结果:[62,14,16,88,59]</div><div style="margin-top: 1em; margin-bottom: 1em;">再次入桶,不过这次以十位数的数字为准,进入相应的桶,变成下边这样:</div><div style="margin-top: 1em; margin-bottom: 1em;">由于前边做了个位数的排序,所以当十位数相等时,个位数字是由小到大的顺序入桶的,就是说,入完桶还是有序</div><div style="margin-top: 1em; margin-bottom: 1em;">| 0 | 14,16 | 0 | 0 | 0 | 59 | 62 | 0 | 88 | 0 |</div><div style="margin-top: 1em; margin-bottom: 1em;">| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |桶编号</div><div style="margin-top: 1em; margin-bottom: 1em;">因为没有大过100的数字,没有百位数,所以到这排序完毕,顺序取出即可</div><div>最后输出结果:[14,16,59,62,88]</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div></span>
</div></body></html> 